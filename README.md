
# Patterns

## Creational Patterns [Порождающие патерны]

- **Abstract Factory** [Абстрактная фабрика] *Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.*
- **Builder** [Строитель] *Позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.*
- **Factory Method** [Фабричный метод] *Определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.*
- **Prototype** [Прототип] *Позволяет копировать объекты, не вдаваясь в подробности их реализации.*
- **Singleton** [Одиночка] *Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.*

## Structural Patterns (Структурные паттерны)

- **Adapter** [Адаптер] *Позволяет объектам с несовместимыми интерфейсами работать вместе.*
- **Bridge** [Мост] *Разделяет один или несколько классов на две отдельные иерархии -- абстракцию и реализацию, позволяя изменять их независимо друг от друга.*
- **Composite** [Компоновщик] *Позволяет сгруппировать объекты в древовидную структуру, а затем работать с ними так, как будто это единичный объект.*
- **Decorator** [Декоратор] *Позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».*
- **Facade** [Фасад] *Предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.*
- **Flyweight** [Легковес] *Позволяет вместить большее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.*
- **Proxy** [Заместитель] *Позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.*

## Behavioral Patterns (Поведенческие паттерны)

- **Chain of Responsibility** [Цепочка обязанностей] *Позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.*
- **Command** [Команда] *Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.*
- **Iterator** [Итератор] *Даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.*
- **Mediator** [Посредник] *Позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.*
- **Memento** [Снимок] *Позволяет делать снимки состояния объектов, не раскрывая подробностей их реализации. Затем снимки можно использовать, чтобы восстановить прошлое состояние объектов.*
- **Observer** [Наблюдатель] *Создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.*
- **State** [Состояние] *Позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.*
- **Strategy** [Стратегия] *Определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.*
- **Template Method** [Шаблонный метод] *Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.*
- **Visitor** [Посетитель] *Позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться.*
